{% set entries = vm.entries %}
{% set max_total = vm.maxTotal %}
{% set chart_role = chart_role | default(request.query_params.get('role', 'today'), true) %}
{% set chart_date = chart_date_iso | default(request.query_params.get('date', 'today'), true) %}
{% set chart_id = 'chart_' ~ chart_role %}
{% set date_string_id = 'dateString_' ~ chart_role %}
{% set section_id = chart_role ~ 'Chart' %}
<section id="{{ section_id }}" class="chart" aria-label="Prices chart" data-date="{{ chart_date }}"
    data-role="{{ chart_role }}" data-margin="{{ request.query_params.get('margin', '0') }}">
    <div class="chart-head">
        {{ chart_role|title }}
        <span class="date-string" id="{{ date_string_id }}"></span>
    </div>
    <div class="chart-body">
        <canvas id="{{ chart_id }}"></canvas>
    </div>
</section>

<script>
    // Chart generation counter to detect stale operations
    window._chartGeneration = window._chartGeneration || { today: 0, tomorrow: 0 };

    // Create chart for {{ chart_date }}
    window.createChart = function (chartDate, chartRoleParam) {
        const date = chartDate || '{{ chart_date }}';
        const role = chartRoleParam || '{{ chart_role }}';
        const margin = '{{ request.query_params.get("margin", "0") }}';
        const chartId = 'chart_' + role;
        const dateStringId = 'dateString_' + role;
        const chartElement = document.getElementById(chartId);
        const dateStringEl = document.getElementById(dateStringId);

        // Increment generation counter - any operations from previous generations should be ignored
        window._chartGeneration[role] = (window._chartGeneration[role] || 0) + 1;
        const thisGeneration = window._chartGeneration[role];
        console.log(`Chart ${role}: starting generation ${thisGeneration} for date ${date}`);

        // Get chart section to update the header text
        const chartSection = document.getElementById(role + 'Chart');
        const chartHeadEl = chartSection ? chartSection.querySelector('.chart-head') : null;

        if (!chartElement) {
            console.error('Chart element not found:', chartId);
            return;
        }

        // Clear all timers for this role FIRST (before destroying old chart)
        if (window.chartRegistry) {
            window.chartRegistry.clearTimersForRole(role);
        }

        // Localize the "Today" or "Tomorrow" label
        if (chartHeadEl) {
            let localizedLabel;
            if (role === 'today') {
                const translations = {
                    'en': 'Today',
                    'fi': 'Tänään',
                    'sv': 'Idag',
                    'de': 'Heute',
                    'fr': "Aujourd'hui",
                    'es': 'Hoy',
                    'it': 'Oggi',
                    'nl': 'Vandaag',
                    'pt': 'Hoje',
                    'ru': 'Сегодня',
                    'pl': 'Dzisiaj',
                };
                const lang = navigator.language.split('-')[0];
                localizedLabel = translations[lang] || translations['en'];
            } else if (role === 'tomorrow') {
                const translations = {
                    'en': 'Tomorrow',
                    'fi': 'Huomenna',
                    'sv': 'Imorgon',
                    'de': 'Morgen',
                    'fr': 'Demain',
                    'es': 'Mañana',
                    'it': 'Domani',
                    'nl': 'Morgen',
                    'pt': 'Amanhã',
                    'ru': 'Завтра',
                    'pl': 'Jutro',
                };
                const lang = navigator.language.split('-')[0];
                localizedLabel = translations[lang] || translations['en'];
            } else {
                localizedLabel = chartHeadEl.textContent.split(' - ')[0] || role;
            }
            chartHeadEl.innerHTML = localizedLabel +
                `<span class="date-string" id="${dateStringId}"></span>`;
        }

        // Check if chart already exists and destroy it using registry
        if (chartElement._chartInstance) {
            if (window.chartRegistry) {
                window.chartRegistry.unregisterChart(chartElement);
            } else {
                try {
                    chartElement._chartInstance.destroy();
                } catch (e) {
                    console.warn('Error destroying chart:', e);
                }
            }
            chartElement._chartInstance = null;
        }

        console.log('Creating chart for:', date, 'role:', role, 'margin:', margin);

        // Fetch chart data with cache-busting to prevent stale data
        const cacheBuster = Date.now();
        fetch(`/api/chart-data?date_str=${encodeURIComponent(date)}&margin=${margin}&_t=${cacheBuster}`, {
            cache: 'no-store',  // Force bypass of browser cache
            headers: {
                'Cache-Control': 'no-cache',
                'Pragma': 'no-cache'
            }
        })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                // Check if this generation is still current
                if (window._chartGeneration[role] !== thisGeneration) {
                    console.warn(`Chart ${role}: generation ${thisGeneration} is stale (current: ${window._chartGeneration[role]}), aborting`);
                    return;
                }

                console.log('Chart data received for', date, 'role:', role, 'rows:', data.data ? data.data.length : 0);

                // Verify chart element is still in DOM and matches expected date
                if (!document.body.contains(chartElement)) {
                    console.warn('Chart element no longer in DOM, aborting');
                    return;
                }
                
                const sectionElement = document.getElementById(role + 'Chart');
                if (sectionElement) {
                    const currentDate = sectionElement.getAttribute('data-date');
                    if (currentDate !== date) {
                        console.warn(`Chart date mismatch: section has ${currentDate}, fetched ${date}. Aborting.`);
                        return;
                    }
                }

                // Update date string with localized format
                const currentDateStringEl = document.getElementById(dateStringId);
                if (currentDateStringEl) {
                    let formattedDate;
                    if (data.dateIso) {
                        const dateObj = new Date(data.dateIso);
                        if (!isNaN(dateObj.getTime())) {
                            const dateFormatter = new Intl.DateTimeFormat(undefined, {
                                weekday: 'long',
                                year: 'numeric',
                                month: 'numeric',
                                day: 'numeric'
                            });
                            let dateStr = dateFormatter.format(dateObj);
                            const lang = navigator.language.split('-')[0];
                            if (lang === 'fi') {
                                const weekdays = {
                                    'maanantaina': 'maanantai',
                                    'tiistaina': 'tiistai',
                                    'keskiviikkona': 'keskiviikko',
                                    'torstaina': 'torstai',
                                    'perjantaina': 'perjantai',
                                    'lauantaina': 'lauantai',
                                    'sunnuntaina': 'sunnuntai'
                                };
                                for (const [inessive, nominative] of Object.entries(weekdays)) {
                                    if (dateStr.toLowerCase().includes(inessive)) {
                                        dateStr = dateStr.replace(new RegExp(inessive, 'gi'), nominative);
                                        break;
                                    }
                                }
                            }
                            formattedDate = dateStr;
                        } else {
                            formattedDate = data.dateString;
                        }
                    } else {
                        formattedDate = data.dateString || '';
                    }
                    currentDateStringEl.textContent = ` - ${formattedDate}`;
                }

                // Validate data with comprehensive integrity checks
                if (!data || typeof data !== 'object') {
                    console.error('Invalid chart data: data is not an object');
                    chartElement.parentElement.innerHTML = '<div style="color: white; padding: 20px; text-align: center;">Error: Invalid data format</div>';
                    return;
                }

                if (!Array.isArray(data.data)) {
                    console.error('Invalid chart data: data.data is not an array');
                    chartElement.parentElement.innerHTML = '<div style="color: white; padding: 20px; text-align: center;">Error: Invalid data format</div>';
                    return;
                }

                // Use validation function if available
                if (typeof window.validateChartData === 'function') {
                    const validationResult = window.validateChartData(data.data, role);
                    if (!validationResult.isValid) {
                        console.error('Chart data validation failed:', validationResult.errors);
                        if (validationResult.validRows < Math.ceil(data.data.length * 0.5)) {
                            chartElement.parentElement.innerHTML = '<div style="color: white; padding: 20px; text-align: center;">Error: Insufficient valid data</div>';
                            return;
                        }
                    }
                }

                // Filter valid data rows
                const validData = data.data.filter(row => {
                    if (!Array.isArray(row)) return false;
                    if (row.length !== 5) return false;
                    const [timeStr] = row;
                    if (timeStr === null || timeStr === undefined) return false;
                    const [, lowPrice, mediumPrice, highPrice, marginPrice] = row;
                    const hasValidPrice = [lowPrice, mediumPrice, highPrice, marginPrice].some(
                        price => typeof price === 'number' && !isNaN(price) && isFinite(price)
                    );
                    return hasValidPrice;
                });

                if (validData.length === 0) {
                    console.error('No valid data rows after filtering');
                    chartElement.parentElement.innerHTML = '<div style="color: white; padding: 20px; text-align: center;">No valid data available</div>';
                    return;
                }

                // Additional validation: check data integrity
                const expectedIntervals = data.expectedIntervalCount || 96;
                if (validData.length < expectedIntervals * 0.5) {
                    console.warn(`Warning: Only ${validData.length} valid data points, expected at least ${Math.ceil(expectedIntervals * 0.5)}`);
                }

                // Store data in global data store (single source of truth)
                const granularity = data.granularity || 'quarter_hour';
                const maxPrice = Math.max(15, data.maxPrice);
                const minPrice = data.minPrice;
                const priceRange = { minPrice, maxPrice };
                
                if (window.chartDataStore) {
                    window.chartDataStore.setData(role, date, validData, granularity, priceRange);
                }

                // Process data for Chart.js
                const labels = [];
                const lowData = [];
                const medData = [];
                const highData = [];
                const marginData = [];

                validData.forEach(row => {
                    const [timeStr, lowPrice, mediumPrice, highPrice, marginPrice] = row;
                    labels.push(timeStr);
                    lowData.push(lowPrice !== 0 ? lowPrice : null);
                    medData.push(mediumPrice !== 0 ? mediumPrice : null);
                    highData.push(highPrice !== 0 ? highPrice : null);
                    marginData.push(marginPrice !== 0 ? marginPrice : null);
                });

                // Add extra label and data point at the end for 0:00 (hour 24)
                // Copy the last bar's data (23:45) to show at 0:00 position with half-width
                // This extends the chart to the correct width so the end grid line is visible
                const lastIndex = validData.length - 1;
                labels.push('96'); // Index for 0:00 (96 = 24 hours * 4 quarters)
                // Copy last bar's data for the half-width bar at 0:00
                lowData.push(lastIndex >= 0 ? lowData[lastIndex] : null);
                medData.push(lastIndex >= 0 ? medData[lastIndex] : null);
                highData.push(lastIndex >= 0 ? highData[lastIndex] : null);
                marginData.push(lastIndex >= 0 ? marginData[lastIndex] : null);

                // Responsive settings
                const isMobile = window.innerWidth <= 900;
                const isTablet = window.innerWidth > 900 && window.innerWidth <= 1200;

                // Prepare annotations for gridlines, vertical lines, and now line
                const annotations = {};

                // Add hourly vertical lines
                // Every 3rd hour (0, 3, 6, 9, 12, 15, 18, 21) is bolder for easier navigation
                const hourStep = 4;
                for (let hour = 0; hour < 24; hour++) {
                    const dataPointIndex = hour * hourStep;
                    if (dataPointIndex < validData.length) {
                        const isMajorHour = hour % 3 === 0;
                        annotations[`vline_${hour}`] = {
                            type: 'line',
                            xMin: dataPointIndex,
                            xMax: dataPointIndex,
                            yMin: minPrice,
                            yMax: maxPrice,
                            borderColor: isMajorHour ? 'rgba(255, 255, 255, 0.4)' : 'rgba(255, 255, 255, 0.2)',
                            borderWidth: isMajorHour ? 2 : 1,
                            drawTime: 'beforeDatasetsDraw',
                            xScaleID: 'x',
                            yScaleID: 'y'
                        };
                    }
                }
                
                // Add grid line at the end of the day (0:00 / hour 24)
                // The x-axis is extended with afterBuildTicks to include index 96
                const endOfDayIndex = validData.length;
                if (endOfDayIndex > 0) {
                    // Hour 24 (0:00 next day) is a major hour (24 % 3 === 0)
                    annotations['vline_24'] = {
                        type: 'line',
                        xMin: endOfDayIndex,
                        xMax: endOfDayIndex,
                        yMin: minPrice,
                        yMax: maxPrice,
                        borderColor: 'rgba(255, 255, 255, 0.4)',
                        borderWidth: 2,
                        drawTime: 'beforeDatasetsDraw',
                        xScaleID: 'x',
                        yScaleID: 'y'
                    };
                }

                // Add horizontal gridlines (every 1 cent, major every 5)
                for (let price = minPrice; price <= maxPrice; price += 1) {
                    const isMajor = price % 5 === 0;
                    annotations[`hline_${price}`] = {
                        type: 'line',
                        yMin: price,
                        yMax: price,
                        xMin: 0,
                        xMax: labels.length > 0 ? labels.length - 1 : 0,
                        borderColor: isMajor ? 'rgba(255, 255, 255, 0.3)' : 'rgba(255, 255, 255, 0.15)',
                        borderWidth: isMajor ? 2 : 1.5,
                        drawTime: 'beforeDatasetsDraw',
                        xScaleID: 'x',
                        yScaleID: 'y'
                    };
                }

                // Add now line for today's chart
                if (role === 'today') {
                    const now = new Date();
                    const currentHour = now.getHours();
                    const currentMinutes = now.getMinutes();
                    const quarter = Math.floor(currentMinutes / 15);
                    const intervalIndex = currentHour * 4 + quarter;
                    const dataPointIndex = validData.findIndex(row => row[0] === intervalIndex.toString());

                    if (dataPointIndex >= 0) {
                        annotations['nowline'] = {
                            type: 'line',
                            xMin: dataPointIndex,
                            xMax: dataPointIndex,
                            yMin: minPrice,
                            yMax: maxPrice,
                            borderColor: 'rgba(255, 153, 0, 0.9)',
                            borderWidth: 3,
                            borderDash: [4, 3],
                            drawTime: 'afterDatasetsDraw',
                            xScaleID: 'x',
                            yScaleID: 'y'
                        };
                    }
                }

                // Chart.js configuration
                const chartConfig = {
                    type: 'bar',
                    data: {
                        labels: labels,
                        datasets: [
                            { label: 'Low Price', data: lowData, backgroundColor: '#2ecc71', stack: 'price' },
                            { label: 'Medium Price', data: medData, backgroundColor: '#f1c40f', stack: 'price' },
                            { label: 'High Price', data: highData, backgroundColor: '#e74c3c', stack: 'price' },
                            { label: 'Margin', data: marginData, backgroundColor: '#666666', stack: 'price' }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false },
                            tooltip: {
                                enabled: false,
                                mode: 'index',
                                intersect: false,
                                animation: false
                            },
                            annotation: {
                                annotations: annotations,
                                clip: false
                            }
                        },
                        // Hook to make the last bar (0:00) half-width
                        afterUpdate: function(chart) {
                            // Make the last bar half-width to match tomorrow's first bar
                            chart.data.datasets.forEach((dataset, datasetIndex) => {
                                const meta = chart.getDatasetMeta(datasetIndex);
                                const lastIndex = meta.data.length - 1;
                                if (lastIndex >= 0 && meta.data[lastIndex]) {
                                    const lastBar = meta.data[lastIndex];
                                    // Calculate half-width based on category width
                                    const xScale = chart.scales.x;
                                    const categoryWidth = xScale.width / (xScale.max - xScale.min + 1);
                                    const barPercentage = (window.innerWidth <= 900 || (window.innerWidth > 900 && window.innerWidth <= 1200)) ? 0.95 : 0.90;
                                    const fullBarWidth = categoryWidth * barPercentage;
                                    const halfBarWidth = fullBarWidth / 2;
                                    
                                    // Adjust the bar width and position
                                    lastBar.width = halfBarWidth;
                                    // Position it at the left edge of the category (centered would be x, but we want it left-aligned for half-width)
                                    const categoryCenter = xScale.getPixelForValue(lastIndex);
                                    lastBar.x = categoryCenter - fullBarWidth / 4;
                                }
                            });
                        },
                        scales: {
                            x: {
                                id: 'x',
                                stacked: true,
                                display: true,
                                barPercentage: (isMobile || isTablet) ? 0.95 : 0.90,
                                categoryPercentage: 1.0,
                                offset: false,
                                ticks: {
                                    color: 'transparent',
                                    font: { size: isMobile ? 10 : (isTablet ? 14 : 12) },
                                    callback: function (value, index, ticks) {
                                        // Show hour labels every 4 intervals (every hour)
                                        if (index % 4 === 0) {
                                            const hour = Math.floor(index / 4);
                                            // Show "0" for hour 24 (0:00 next day) at the end
                                            return hour === 24 ? '0' : hour.toString();
                                        }
                                        return '';
                                    },
                                    maxRotation: 0,
                                    minRotation: 0
                                },
                                grid: { display: false }
                            },
                            y: {
                                id: 'y',
                                stacked: true,
                                min: minPrice,
                                max: maxPrice,
                                ticks: {
                                    color: 'white',
                                    font: { size: isMobile ? 12 : (isTablet ? 14 : 12) },
                                    stepSize: 1,
                                    callback: function (value) {
                                        return value % 5 === 0 ? value : '';
                                    }
                                },
                                grid: { display: false }
                            }
                        },
                        interaction: { mode: 'index', intersect: true },
                        onHover: function (event, elements) {
                            event.native.target.style.cursor = elements.length > 0 ? 'pointer' : 'default';
                        },
                        onClick: function (event, elements) {
                            if (elements.length === 0) return;
                            const chart = this;
                            const index = elements[0].index;
                            
                            // Use data from global store to ensure freshness
                            let rowData = validData[index];
                            if (window.chartDataStore) {
                                const storeData = window.chartDataStore.getData(role, date);
                                if (storeData && storeData.data && storeData.data[index]) {
                                    rowData = storeData.data[index];
                                }
                            }
                            if (!rowData) return;

                            const tooltipId = 'chartjs-tooltip-click-' + role;
                            let tooltipEl = document.getElementById(tooltipId);
                            if (!tooltipEl) {
                                tooltipEl = document.createElement('div');
                                tooltipEl.id = tooltipId;
                                tooltipEl.style.cssText = 'position: absolute; pointer-events: none; opacity: 0; z-index: 1000; background: rgba(255, 255, 255, 0.95); border: 1px solid #ddd; border-radius: 4px; padding: 8px; font-family: Arial, sans-serif; font-size: 13px; box-shadow: 0 2px 8px rgba(0,0,0,0.2);';
                                document.body.appendChild(tooltipEl);
                            }

                            const [timeStr, lowPrice, mediumPrice, highPrice, marginPrice] = rowData;
                            const spotPrice = (lowPrice || 0) + (mediumPrice || 0) + (highPrice || 0);
                            const totalPrice = spotPrice + (marginPrice || 0);

                            const intervalIndex = parseInt(timeStr);
                            const hour = Math.floor(intervalIndex / 4);
                            const quarter = intervalIndex % 4;
                            const minute = quarter * 15;
                            const timeFormatted = `${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;

                            let tooltipHTML = `<div style="font-weight: bold; margin-bottom: 4px; color: #333;">${timeFormatted}</div>`;
                            if (lowPrice) tooltipHTML += `<div style="color: #666;">Price: <strong>${lowPrice.toFixed(2)} c/kWh</strong></div>`;
                            if (mediumPrice) tooltipHTML += `<div style="color: #666;">Price: <strong>${mediumPrice.toFixed(2)} c/kWh</strong></div>`;
                            if (highPrice) tooltipHTML += `<div style="color: #666;">Price: <strong>${highPrice.toFixed(2)} c/kWh</strong></div>`;
                            tooltipHTML += `<div style="color: #666;">Margin: <strong>${(marginPrice || 0).toFixed(2)} c/kWh</strong></div>`;
                            tooltipHTML += `<div style="border-top: 1px solid #ddd; margin-top: 4px; padding-top: 4px; color: #333;"><strong>Total: ${totalPrice.toFixed(2)} c/kWh</strong></div>`;

                            tooltipEl.innerHTML = tooltipHTML;
                            tooltipEl.style.opacity = '1';

                            const canvasRect = chart.canvas.getBoundingClientRect();
                            const tooltipWidth = tooltipEl.offsetWidth || 200;
                            const tooltipHeight = tooltipEl.offsetHeight || 100;
                            const x = event.native.clientX - canvasRect.left;
                            const y = event.native.clientY - canvasRect.top;

                            let leftPos = canvasRect.left + x + 10;
                            let topPos = canvasRect.top + y - tooltipHeight - 10;
                            if (leftPos + tooltipWidth > window.innerWidth) leftPos = canvasRect.left + x - tooltipWidth - 10;
                            if (topPos < 0) topPos = canvasRect.top + y + 10;

                            tooltipEl.style.left = leftPos + 'px';
                            tooltipEl.style.top = topPos + 'px';

                            const hideTooltip = function (e) {
                                if (!tooltipEl.contains(e.target) && e.target !== chart.canvas) {
                                    tooltipEl.style.opacity = '0';
                                    document.removeEventListener('click', hideTooltip);
                                }
                            };
                            setTimeout(() => document.addEventListener('click', hideTooltip), 0);
                        },
                        animation: { duration: 0 }
                    }
                };

                // Verify chart element is still in DOM
                if (!document.body.contains(chartElement)) {
                    console.error('Chart element no longer in DOM, aborting chart creation');
                    return;
                }

                // Register half-width last bar plugin ONCE globally (not on every chart creation)
                if (!window._halfWidthPluginRegistered) {
                    const halfWidthLastBarPlugin = {
                        id: 'halfWidthLastBar',
                        beforeDatasetsDraw: function(chart) {
                            // Only apply to charts with the extra 0:00 bar
                            if (!chart.canvas || !chart.canvas._chartRole) return;
                            
                            const lastIndex = chart.data.labels.length - 1;
                            if (lastIndex >= 0 && chart.data.labels[lastIndex] === '96') {
                                chart.data.datasets.forEach((dataset, datasetIndex) => {
                                    const meta = chart.getDatasetMeta(datasetIndex);
                                    if (meta.data[lastIndex]) {
                                        meta.data[lastIndex].hidden = true;
                                    }
                                });
                            }
                        },
                        afterDatasetsDraw: function(chart) {
                            // Only apply to charts with the extra 0:00 bar
                            if (!chart.canvas || !chart.canvas._chartRole) return;
                            
                            const lastIndex = chart.data.labels.length - 1;
                            if (lastIndex < 0 || chart.data.labels[lastIndex] !== '96') return;
                            
                            const ctx = chart.ctx;
                            const xScale = chart.scales.x;
                            const yScale = chart.scales.y;
                            
                            if (!xScale || !yScale) return;
                            
                            const categoryWidth = xScale.width / (xScale.max - xScale.min + 1);
                            const barPercentage = (window.innerWidth <= 900 || (window.innerWidth > 900 && window.innerWidth <= 1200)) ? 0.95 : 0.90;
                            const fullBarWidth = categoryWidth * barPercentage;
                            const halfBarWidth = fullBarWidth / 2;
                            const categoryCenter = xScale.getPixelForValue(lastIndex);
                            const halfBarX = categoryCenter - fullBarWidth / 4;
                            
                            // Draw stacked bar segments from bottom to top
                            let currentY = yScale.getPixelForValue(0);
                            chart.data.datasets.forEach((dataset, datasetIndex) => {
                                const value = dataset.data[lastIndex];
                                if (value !== null && value !== undefined && value !== 0) {
                                    let cumulativeValue = 0;
                                    for (let i = 0; i <= datasetIndex; i++) {
                                        const segValue = chart.data.datasets[i].data[lastIndex];
                                        if (segValue !== null && segValue !== undefined) {
                                            cumulativeValue += segValue;
                                        }
                                    }
                                    
                                    const segmentTop = yScale.getPixelForValue(cumulativeValue);
                                    const segmentHeight = currentY - segmentTop;
                                    
                                    ctx.save();
                                    ctx.fillStyle = dataset.backgroundColor;
                                    ctx.fillRect(halfBarX, segmentTop, halfBarWidth, segmentHeight);
                                    ctx.restore();
                                    
                                    currentY = segmentTop;
                                }
                            });
                        }
                    };
                    
                    Chart.register(halfWidthLastBarPlugin);
                    window._halfWidthPluginRegistered = true;
                    console.log('Half-width last bar plugin registered');
                }

                // Create chart
                let chart;
                try {
                    chart = new Chart(chartElement, chartConfig);
                } catch (e) {
                    console.error('Error creating chart:', e);
                    chartElement.parentElement.innerHTML = '<div style="color: white; padding: 20px; text-align: center;">Error creating chart</div>';
                    return;
                }

                // Register chart instance with global registry INCLUDING date
                if (window.chartRegistry) {
                    window.chartRegistry.registerChart(chartElement, chart, role, date);
                }

                // Add hour labels
                chart.canvas.parentElement.style.position = 'relative';
                const labelContainer = document.createElement('div');
                labelContainer.style.cssText = 'position: absolute; bottom: 0; left: 0; right: 0; height: 30px; pointer-events: none;';
                labelContainer.className = 'chart-hour-labels';
                chart.canvas.parentElement.appendChild(labelContainer);

                function updateHourLabels() {
                    if (!document.body.contains(labelContainer)) return;
                    labelContainer.innerHTML = '';

                    const chartArea = chart.chartArea;
                    const scale = chart.scales.x;
                    if (!chartArea || !scale) {
                        setTimeout(updateHourLabels, 100);
                        return;
                    }

                    // Check if mobile vertical mode (mobile width AND portrait orientation)
                    const isMobileVertical = isMobile && window.innerHeight > window.innerWidth;

                    for (let hour = 0; hour < 24; hour++) {
                        // On mobile vertical mode, only show every 2nd hour (0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22)
                        if (isMobileVertical && hour % 2 !== 0) {
                            continue;
                        }

                        const dataPointIndex = hour * 4;
                        if (dataPointIndex < labels.length) {
                            try {
                                const xPos = scale.getPixelForValue(dataPointIndex);
                                const barPercentage = (isMobile || isTablet) ? 0.95 : 0.90;
                                const categoryWidth = scale.width / labels.length;
                                const barWidth = categoryWidth * barPercentage;
                                const leftEdge = xPos - (barWidth / 2);

                                const label = document.createElement('div');
                                label.textContent = hour.toString();
                                label.style.cssText = `position: absolute; left: ${leftEdge}px; bottom: 5px; color: white; font-size: 12px; font-family: Arial, sans-serif; pointer-events: none; white-space: nowrap;`;
                                labelContainer.appendChild(label);
                            } catch (e) {
                                console.warn('Error positioning hour label:', e);
                            }
                        }
                    }
                }

                chart.update();
                setTimeout(updateHourLabels, 100);

                const originalResize = chart.resize;
                chart.resize = function () {
                    originalResize.call(this);
                    setTimeout(updateHourLabels, 100);
                };

                // Final generation check before storing
                if (window._chartGeneration[role] !== thisGeneration) {
                    console.warn(`Chart ${role}: generation ${thisGeneration} became stale during creation, destroying`);
                    chart.destroy();
                    return;
                }

                // Store chart instance and metadata on canvas (for compatibility)
                chartElement._chartInstance = chart;
                chartElement._chartDate = date;  // Store the date this chart was created for
                chartElement._chartRole = role;
                chartElement._chartGeneration = thisGeneration;  // Store generation for timer validation

                // Set up now line timer for today's chart
                if (role === 'today') {
                    setupNowLineTimer(role, date, thisGeneration);
                    if (window.updateCurrentPrice) {
                        window.updateCurrentPrice();
                    }
                }

                console.log(`Chart created successfully for ${role} (gen ${thisGeneration}), date: ${date}, dataPoints: ${validData.length}`);
            })
            .catch(error => {
                console.error('Error fetching chart data:', error);
                if (document.body.contains(chartElement)) {
                    chartElement.parentElement.innerHTML = '<div style="color: white; padding: 20px;">Error loading chart data</div>';
                }
            });

        // Now line timer that uses global data store and validates generation
        function setupNowLineTimer(role, chartDate, generation) {
            function updateNowLineFromStore() {
                // Check if this timer's generation is still current
                if (window._chartGeneration[role] !== generation) {
                    console.log(`Now line timer (gen ${generation}): stale, current is ${window._chartGeneration[role]}`);
                    return;
                }
                
                if (document.hidden) return;
                
                // Get current expected date
                const expectedDate = window.getHelsinkiDate ? window.getHelsinkiDate(0) : null;
                
                // If date has changed, don't update - let the refresh handle it
                if (expectedDate && chartDate !== expectedDate) {
                    console.log('Now line timer: date changed, skipping update');
                    return;
                }
                
                // Verify the chart canvas still matches our generation
                const canvas = document.querySelector('#todayChart canvas');
                if (!canvas || canvas._chartGeneration !== generation) {
                    console.log(`Now line timer (gen ${generation}): canvas generation mismatch`);
                    return;
                }
                
                // Use global updateNowLine which reads from data store
                if (window.updateNowLine) {
                    window.updateNowLine();
                }
            }

            function msUntilNext15Min() {
                const now = new Date();
                const minutes = now.getMinutes();
                const seconds = now.getSeconds();
                const ms = now.getMilliseconds();
                const nextBoundary = Math.ceil(minutes / 15) * 15;
                const minutesUntil = nextBoundary === 60 ? (60 - minutes) : (nextBoundary - minutes);
                return (minutesUntil * 60 * 1000) - (seconds * 1000) - ms;
            }

            function scheduleNext() {
                // Don't schedule if already stale
                if (window._chartGeneration[role] !== generation) {
                    console.log(`Now line timer (gen ${generation}): not scheduling, already stale`);
                    return;
                }
                
                const ms = msUntilNext15Min();
                console.log(`Now line timer (gen ${generation}): scheduling for ${ms}ms`);
                
                const timeoutId = setTimeout(() => {
                    // Check generation before doing anything
                    if (window._chartGeneration[role] !== generation) {
                        console.log(`Now line timer (gen ${generation}): timeout fired but stale`);
                        return;
                    }
                    
                    updateNowLineFromStore();
                    
                    // Only set up interval if still current generation
                    if (window._chartGeneration[role] === generation) {
                        const intervalId = setInterval(() => {
                            if (window._chartGeneration[role] !== generation) {
                                // Clear this interval since we're stale
                                clearInterval(intervalId);
                                return;
                            }
                            updateNowLineFromStore();
                        }, 15 * 60 * 1000);
                        
                        if (window.chartRegistry) {
                            window.chartRegistry.trackTimer(intervalId, role, 'now-line-interval');
                        }
                    }
                }, ms);
                
                if (window.chartRegistry) {
                    window.chartRegistry.trackTimer(timeoutId, role, 'now-line-timeout');
                }
            }

            scheduleNext();
        }
    };

    // Execute chart creation
    if (typeof Chart !== 'undefined') {
        window.createChart('{{ chart_date }}', '{{ chart_role }}');
    } else {
        const checkChart = setInterval(() => {
            if (typeof Chart !== 'undefined') {
                clearInterval(checkChart);
                window.createChart('{{ chart_date }}', '{{ chart_role }}');
            }
        }, 100);
    }
</script>
