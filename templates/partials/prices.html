{% set entries = vm.entries %}
{% set max_total = vm.maxTotal %}
{% set chart_role = chart_role | default(request.query_params.get('role', 'today'), true) %}
{% set chart_date = chart_date_iso | default(request.query_params.get('date', 'today'), true) %}
{% set chart_id = 'chart_' ~ chart_role %}
{% set date_string_id = 'dateString_' ~ chart_role %}
{% set section_id = chart_role ~ 'Chart' %}
<section id="{{ section_id }}" class="chart" aria-label="Prices chart" data-date="{{ chart_date }}"
    data-role="{{ chart_role }}" data-margin="{{ request.query_params.get('margin', '0') }}">
    <div class="chart-head">
        {{ chart_role|title }}
        <span class="date-string" id="{{ date_string_id }}"></span>
    </div>
    <div class="chart-body">
        <canvas id="{{ chart_id }}"></canvas>
    </div>
</section>

<script>
    // Chart generation counter to detect stale operations
    window._chartGeneration = window._chartGeneration || { today: 0, tomorrow: 0 };

    // Create chart for {{ chart_date }}
    window.createChart = function (chartDate, chartRoleParam) {
        const date = chartDate || '{{ chart_date }}';
        const role = chartRoleParam || '{{ chart_role }}';
        const margin = '{{ request.query_params.get("margin", "0") }}';
        const chartId = 'chart_' + role;
        const dateStringId = 'dateString_' + role;
        const chartElement = document.getElementById(chartId);
        const dateStringEl = document.getElementById(dateStringId);

        // Increment generation counter - any operations from previous generations should be ignored
        window._chartGeneration[role] = (window._chartGeneration[role] || 0) + 1;
        const thisGeneration = window._chartGeneration[role];
        console.log(`Chart ${role}: starting generation ${thisGeneration} for date ${date}`);

        // Get chart section to update the header text
        const chartSection = document.getElementById(role + 'Chart');
        const chartHeadEl = chartSection ? chartSection.querySelector('.chart-head') : null;

        if (!chartElement) {
            console.error('Chart element not found:', chartId);
            return;
        }

        // Clear all timers for this role FIRST (before destroying old chart)
        if (window.chartRegistry) {
            window.chartRegistry.clearTimersForRole(role);
        }

        // Localize the "Today" or "Tomorrow" label
        if (chartHeadEl) {
            let localizedLabel;
            if (role === 'today') {
                const translations = {
                    'en': 'Today',
                    'fi': 'Tänään',
                    'sv': 'Idag',
                    'de': 'Heute',
                    'fr': "Aujourd'hui",
                    'es': 'Hoy',
                    'it': 'Oggi',
                    'nl': 'Vandaag',
                    'pt': 'Hoje',
                    'ru': 'Сегодня',
                    'pl': 'Dzisiaj',
                };
                const lang = navigator.language.split('-')[0];
                localizedLabel = translations[lang] || translations['en'];
            } else if (role === 'tomorrow') {
                const translations = {
                    'en': 'Tomorrow',
                    'fi': 'Huomenna',
                    'sv': 'Imorgon',
                    'de': 'Morgen',
                    'fr': 'Demain',
                    'es': 'Mañana',
                    'it': 'Domani',
                    'nl': 'Morgen',
                    'pt': 'Amanhã',
                    'ru': 'Завтра',
                    'pl': 'Jutro',
                };
                const lang = navigator.language.split('-')[0];
                localizedLabel = translations[lang] || translations['en'];
            } else {
                localizedLabel = chartHeadEl.textContent.split(' - ')[0] || role;
            }
            chartHeadEl.innerHTML = localizedLabel +
                `<span class="date-string" id="${dateStringId}"></span>`;
        }

        // Check if chart already exists and destroy it using registry
        if (chartElement._chartInstance) {
            if (window.chartRegistry) {
                window.chartRegistry.unregisterChart(chartElement);
            } else {
                try {
                    chartElement._chartInstance.destroy();
                } catch (e) {
                    console.warn('Error destroying chart:', e);
                }
            }
            chartElement._chartInstance = null;
        }

        console.log('Creating chart for:', date, 'role:', role, 'margin:', margin);

        // Fetch chart data with cache-busting to prevent stale data
        const cacheBuster = Date.now();
        fetch(`/api/chart-data?date_str=${encodeURIComponent(date)}&margin=${margin}&_t=${cacheBuster}`, {
            cache: 'no-store',  // Force bypass of browser cache
            headers: {
                'Cache-Control': 'no-cache',
                'Pragma': 'no-cache'
            }
        })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                // Check if this generation is still current
                if (window._chartGeneration[role] !== thisGeneration) {
                    console.warn(`Chart ${role}: generation ${thisGeneration} is stale (current: ${window._chartGeneration[role]}), aborting`);
                    return;
                }

                console.log('Chart data received for', date, 'role:', role, 'rows:', data.data ? data.data.length : 0);

                // Verify chart element is still in DOM and matches expected date
                if (!document.body.contains(chartElement)) {
                    console.warn('Chart element no longer in DOM, aborting');
                    return;
                }

                const sectionElement = document.getElementById(role + 'Chart');
                if (sectionElement) {
                    const currentDate = sectionElement.getAttribute('data-date');
                    if (currentDate !== date) {
                        console.warn(`Chart date mismatch: section has ${currentDate}, fetched ${date}. Aborting.`);
                        return;
                    }
                }

                // Update date string with localized format
                const currentDateStringEl = document.getElementById(dateStringId);
                if (currentDateStringEl) {
                    let formattedDate;
                    if (data.dateIso) {
                        const dateObj = new Date(data.dateIso);
                        if (!isNaN(dateObj.getTime())) {
                            const dateFormatter = new Intl.DateTimeFormat(undefined, {
                                weekday: 'long',
                                year: 'numeric',
                                month: 'numeric',
                                day: 'numeric'
                            });
                            let dateStr = dateFormatter.format(dateObj);
                            const lang = navigator.language.split('-')[0];
                            if (lang === 'fi') {
                                const weekdays = {
                                    'maanantaina': 'maanantai',
                                    'tiistaina': 'tiistai',
                                    'keskiviikkona': 'keskiviikko',
                                    'torstaina': 'torstai',
                                    'perjantaina': 'perjantai',
                                    'lauantaina': 'lauantai',
                                    'sunnuntaina': 'sunnuntai'
                                };
                                for (const [inessive, nominative] of Object.entries(weekdays)) {
                                    if (dateStr.toLowerCase().includes(inessive)) {
                                        dateStr = dateStr.replace(new RegExp(inessive, 'gi'), nominative);
                                        break;
                                    }
                                }
                            }
                            formattedDate = dateStr;
                        } else {
                            formattedDate = data.dateString;
                        }
                    } else {
                        formattedDate = data.dateString || '';
                    }
                    currentDateStringEl.textContent = ` - ${formattedDate}`;
                }

                // Validate data with comprehensive integrity checks
                if (!data || typeof data !== 'object') {
                    console.error('Invalid chart data: data is not an object');
                    chartElement.parentElement.innerHTML = '<div style="color: white; padding: 20px; text-align: center;">Error: Invalid data format</div>';
                    return;
                }

                if (!Array.isArray(data.data)) {
                    console.error('Invalid chart data: data.data is not an array');
                    chartElement.parentElement.innerHTML = '<div style="color: white; padding: 20px; text-align: center;">Error: Invalid data format</div>';
                    return;
                }

                // Use validation function if available
                if (typeof window.validateChartData === 'function') {
                    const validationResult = window.validateChartData(data.data, role);
                    if (!validationResult.isValid) {
                        console.error('Chart data validation failed:', validationResult.errors);
                        if (validationResult.validRows < Math.ceil(data.data.length * 0.5)) {
                            chartElement.parentElement.innerHTML = '<div style="color: white; padding: 20px; text-align: center;">Error: Insufficient valid data</div>';
                            return;
                        }
                    }
                }

                // Filter valid data rows
                const validData = data.data.filter(row => {
                    if (!Array.isArray(row)) return false;
                    if (row.length !== 5) return false;
                    const [timeStr] = row;
                    if (timeStr === null || timeStr === undefined) return false;
                    const [, lowPrice, mediumPrice, highPrice, marginPrice] = row;
                    const hasValidPrice = [lowPrice, mediumPrice, highPrice, marginPrice].some(
                        price => typeof price === 'number' && !isNaN(price) && isFinite(price)
                    );
                    return hasValidPrice;
                });

                if (validData.length === 0) {
                    console.error('No valid data rows after filtering');
                    chartElement.parentElement.innerHTML = '<div style="color: white; padding: 20px; text-align: center;">No valid data available</div>';
                    return;
                }

                // Additional validation: check data integrity
                const expectedIntervals = data.expectedIntervalCount || 96;
                if (validData.length < expectedIntervals * 0.5) {
                    console.warn(`Warning: Only ${validData.length} valid data points, expected at least ${Math.ceil(expectedIntervals * 0.5)}`);
                }

                // Store data in global data store (single source of truth)
                const granularity = data.granularity || 'quarter_hour';

                // Initialize global price range tracker if it doesn't exist
                if (!window.globalPriceRange) {
                    window.globalPriceRange = { minPrice: null, maxPrice: null };
                }

                // Helper function to check if data contains any negative spot prices
                // and calculate actual min/max values from data
                function calculateDataRange(dataArray) {
                    let min = Infinity;
                    let max = -Infinity;
                    let hasNegative = false;

                    if (dataArray && Array.isArray(dataArray)) {
                        for (const row of dataArray) {
                            if (Array.isArray(row) && row.length >= 5) {
                                const [, lowPrice, mediumPrice, highPrice, marginPrice] = row;
                                const spotPrice = (lowPrice || 0) + (mediumPrice || 0) + (highPrice || 0);
                                const totalPrice = spotPrice + (marginPrice || 0);

                                if (spotPrice < min) min = spotPrice;
                                if (totalPrice > max) max = totalPrice;
                                if (spotPrice < 0) hasNegative = true;
                            }
                        }
                    }

                    // If no valid data or min/max not set, return defaults
                    if (min === Infinity) min = 0;
                    if (max === -Infinity) max = 15;

                    return { min, max, hasNegative };
                }

                // Calculate range for current chart data
                const currentRange = calculateDataRange(validData);

                // Initialize global tracking variables with current chart values
                let globalMin = currentRange.min;
                let globalMax = currentRange.max;
                let anyNegative = currentRange.hasNegative;

                // Check other chart data from store to update global range
                if (window.chartDataStore) {
                    const otherRole = role === 'today' ? 'tomorrow' : 'today';
                    const otherData = window.chartDataStore.getData(otherRole);

                    if (otherData && otherData.data) {
                        const otherRange = calculateDataRange(otherData.data);
                        globalMin = Math.min(globalMin, otherRange.min);
                        globalMax = Math.max(globalMax, otherRange.max);
                        if (otherRange.hasNegative) anyNegative = true;
                    }
                }

                // Apply rounding and clamping logic (matching backend logic)

                // Max: Always at least 15 cents. Round up to next 5 cents.
                // If max is 17.2, it becomes 20. If 12, it becomes 15.
                if (globalMax <= 0) {
                    globalMax = 15;
                } else {
                    // Use Math.ceil(val / 5) * 5 logic
                    const rawMax = Math.max(15, globalMax);
                    if (rawMax % 5 === 0) {
                        globalMax = Math.ceil(rawMax);
                    } else {
                        globalMax = Math.ceil(rawMax / 5) * 5;
                    }
                }

                // Min: If no negative prices, force 0. Else round down to integer.
                // If min is -0.5, it becomes -1. If 2.5 (and no negatives anywhere), it becomes 0.
                if (!anyNegative && globalMin >= 0) {
                    globalMin = 0;
                } else {
                    globalMin = Math.floor(globalMin);
                }

                // Update global range tracker
                if (!window.globalPriceRange) {
                    window.globalPriceRange = { minPrice: null, maxPrice: null };
                }

                // Check if range changed
                const previousGlobalMin = window.globalPriceRange.minPrice;
                const previousGlobalMax = window.globalPriceRange.maxPrice;
                const rangeChanged = previousGlobalMin !== globalMin || previousGlobalMax !== globalMax;

                window.globalPriceRange.minPrice = globalMin;
                window.globalPriceRange.maxPrice = globalMax;

                // If global range changed, update the OTHER chart if it exists
                if (rangeChanged && window.chartRegistry) {
                    const otherRole = role === 'today' ? 'tomorrow' : 'today';
                    const otherChartInfo = window.chartRegistry.getChartByRole(otherRole);

                    if (otherChartInfo && otherChartInfo.instance) {
                        try {
                            const chartInstance = otherChartInfo.instance;
                            // Check if scale exists and needs update
                            if (chartInstance.scales && chartInstance.scales.y) {
                                const yScale = chartInstance.scales.y;
                                if (yScale.min !== globalMin || yScale.max !== globalMax) {
                                    console.log(`Updating ${otherRole} chart y-axis to ${globalMin} - ${globalMax}`);

                                    // Update scale options
                                    chartInstance.options.scales.y.min = globalMin;
                                    chartInstance.options.scales.y.max = globalMax;

                                    // Update annotations if they rely on min/max
                                    if (chartInstance.options.plugins && chartInstance.options.plugins.annotation) {
                                        const annotations = chartInstance.options.plugins.annotation.annotations;
                                        if (annotations) {
                                            // Remove old horizontal gridlines
                                            Object.keys(annotations).forEach(key => {
                                                if (key.startsWith('hline_')) {
                                                    delete annotations[key];
                                                }
                                            });

                                            // Add horizontal gridlines for the new global range
                                            // Calculate gridline offset to match the shifted vertical gridlines
                                            // Position gridlines exactly between bars
                                            const gridlineOffset = 0.5; // Shift left by 0.5 to position between bars

                                            for (let price = globalMin; price <= globalMax; price += 1) {
                                                const isMajor = price % 5 === 0;
                                                annotations[`hline_${price}`] = {
                                                    type: 'line',
                                                    yMin: price,
                                                    yMax: price,
                                                    xMin: 0 - gridlineOffset, // Start from shifted left position (before first bar)
                                                    xMax: 96 - gridlineOffset, // End at shifted right position (at right edge of last bar)
                                                    borderColor: isMajor ? 'rgba(255, 255, 255, 0.3)' : 'rgba(255, 255, 255, 0.15)',
                                                    borderWidth: isMajor ? 2 : 1.5,
                                                    drawTime: 'beforeDatasetsDraw',
                                                    xScaleID: 'x',
                                                    yScaleID: 'y'
                                                };
                                            }

                                            // Update vertical lines to span full height
                                            Object.keys(annotations).forEach(key => {
                                                const ann = annotations[key];
                                                if (key.startsWith('vline_') || key.startsWith('nowline')) {
                                                    if (ann.yMin !== undefined) ann.yMin = globalMin;
                                                    if (ann.yMax !== undefined) ann.yMax = globalMax;
                                                }
                                            });
                                        }
                                    }

                                    chartInstance.update('none');
                                }
                            }
                        } catch (e) {
                            console.warn(`Error updating ${otherRole} chart scales:`, e);
                        }
                    }
                }

                // Use global range for consistent scaling
                const maxPrice = window.globalPriceRange.maxPrice;
                const minPrice = window.globalPriceRange.minPrice;
                const priceRange = { minPrice, maxPrice };

                if (window.chartDataStore) {
                    window.chartDataStore.setData(role, date, validData, granularity, priceRange);
                }

                // Process data for Chart.js
                const labels = [];
                const lowData = [];
                const medData = [];
                const highData = [];
                const marginData = [];

                validData.forEach(row => {
                    const [timeStr, lowPrice, mediumPrice, highPrice, marginPrice] = row;
                    labels.push(timeStr);
                    lowData.push(lowPrice !== 0 ? lowPrice : null);
                    medData.push(mediumPrice !== 0 ? mediumPrice : null);
                    highData.push(highPrice !== 0 ? highPrice : null);
                    marginData.push(marginPrice !== 0 ? marginPrice : null);
                });

                // Add pseudo bar at the end with zero values to extend x-axis for rightmost gridline
                labels.push('96'); // Index for 0:00 (96 = 24 hours * 4 quarters)
                lowData.push(null);
                medData.push(null);
                highData.push(null);
                marginData.push(null);

                // Responsive settings
                const isMobile = window.innerWidth <= 900;
                const isTablet = window.innerWidth > 900 && window.innerWidth <= 1200;

                // Prepare annotations for gridlines, vertical lines, and now line
                const annotations = {};

                // Add hourly vertical lines
                // Every 3rd hour (0, 3, 6, 9, 12, 15, 18, 21) is bolder for easier navigation
                // Position gridlines exactly between bars (at the midpoint of the gap)
                // Bars are centered on ticks, so gap midpoint is at tick + 0.5
                // To position gridline at tick i to be between bars, shift to i - 0.5
                const barPercentage = (isMobile || isTablet) ? 0.95 : 0.90;
                const gridlineOffset = 0.5; // Shift left by 0.5 to position between bars

                const hourStep = 4;
                for (let hour = 0; hour < 24; hour++) {
                    const dataPointIndex = hour * hourStep;
                    if (dataPointIndex < validData.length) {
                        const isMajorHour = hour % 3 === 0;
                        // Shift left by half bar width
                        const shiftedIndex = dataPointIndex - gridlineOffset;
                        annotations[`vline_${hour}`] = {
                            type: 'line',
                            xMin: shiftedIndex,
                            xMax: shiftedIndex,
                            yMin: minPrice,
                            yMax: maxPrice,
                            borderColor: isMajorHour ? 'rgba(255, 255, 255, 0.4)' : 'rgba(255, 255, 255, 0.2)',
                            borderWidth: isMajorHour ? 2 : 1,
                            drawTime: 'beforeDatasetsDraw',
                            xScaleID: 'x',
                            yScaleID: 'y'
                        };
                    }
                }

                // Add grid line at the end of the day (at index 96, after last bar at 23:45)
                // Position it at the right edge of the last actual bar
                const lastBarIndex = validData.length - 1; // Index 95 (23:45)
                if (lastBarIndex >= 0) {
                    // Position at index 96, shifted left by half bar width
                    const shiftedEndIndex = 96 - gridlineOffset;
                    annotations['vline_24'] = {
                        type: 'line',
                        xMin: shiftedEndIndex,
                        xMax: shiftedEndIndex,
                        yMin: minPrice,
                        yMax: maxPrice,
                        borderColor: 'rgba(255, 255, 255, 0.4)',
                        borderWidth: 2,
                        drawTime: 'beforeDatasetsDraw',
                        xScaleID: 'x',
                        yScaleID: 'y'
                    };
                }

                // Add horizontal gridlines (every 1 cent, major every 5)
                // Shift to align with shifted vertical gridlines
                const lastDataIndex = labels.length > 0 ? labels.length - 1 : 0; // Index 96 (pseudo bar)
                for (let price = minPrice; price <= maxPrice; price += 1) {
                    const isMajor = price % 5 === 0;
                    annotations[`hline_${price}`] = {
                        type: 'line',
                        yMin: price,
                        yMax: price,
                        xMin: 0 - gridlineOffset, // Start from shifted left position (before first bar)
                        xMax: 96 - gridlineOffset, // End at shifted right position (at right edge of last bar)
                        borderColor: isMajor ? 'rgba(255, 255, 255, 0.3)' : 'rgba(255, 255, 255, 0.15)',
                        borderWidth: isMajor ? 2 : 1.5,
                        drawTime: 'beforeDatasetsDraw',
                        xScaleID: 'x',
                        yScaleID: 'y'
                    };
                }

                // Add now line for today's chart
                if (role === 'today') {
                    const now = new Date();
                    const currentHour = now.getHours();
                    const currentMinutes = now.getMinutes();
                    const quarter = Math.floor(currentMinutes / 15);
                    const intervalIndex = currentHour * 4 + quarter;
                    const dataPointIndex = validData.findIndex(row => row[0] === intervalIndex.toString());

                    if (dataPointIndex >= 0) {
                        annotations['nowline'] = {
                            type: 'line',
                            xMin: dataPointIndex,
                            xMax: dataPointIndex,
                            yMin: minPrice,
                            yMax: maxPrice,
                            borderColor: 'rgba(255, 153, 0, 0.9)',
                            borderWidth: 3,
                            borderDash: [4, 3],
                            drawTime: 'afterDatasetsDraw',
                            xScaleID: 'x',
                            yScaleID: 'y'
                        };
                    }
                }

                // Chart.js configuration
                const chartConfig = {
                    type: 'bar',
                    data: {
                        labels: labels,
                        datasets: [
                            { label: 'Low Price', data: lowData, backgroundColor: '#2ecc71', stack: 'price' },
                            { label: 'Medium Price', data: medData, backgroundColor: '#f1c40f', stack: 'price' },
                            { label: 'High Price', data: highData, backgroundColor: '#e74c3c', stack: 'price' },
                            { label: 'Margin', data: marginData, backgroundColor: '#666666', stack: 'price' }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        layout: {
                            padding: {
                                left: 0,
                                right: 0
                            }
                        },
                        plugins: {
                            legend: { display: false },
                            tooltip: {
                                enabled: false,
                                mode: 'index',
                                intersect: false,
                                animation: false
                            },
                            annotation: {
                                annotations: annotations,
                                clip: false
                            }
                        },
                        scales: {
                            x: {
                                id: 'x',
                                stacked: true,
                                display: true,
                                barPercentage: (isMobile || isTablet) ? 0.95 : 0.90,
                                categoryPercentage: 1.0,
                                offset: true, // Add padding on both sides so first/last bars render at full width
                                bounds: 'ticks',
                                ticks: {
                                    color: 'transparent',
                                    font: { size: isMobile ? 10 : (isTablet ? 14 : 12) },
                                    callback: function (value, index, ticks) {
                                        // Show hour labels every 4 intervals (every hour)
                                        if (index % 4 === 0) {
                                            const hour = Math.floor(index / 4);
                                            // Don't show hour 24 as we no longer have the extra bar
                                            if (hour >= 24) return '';
                                            return hour.toString();
                                        }
                                        return '';
                                    },
                                    maxRotation: 0,
                                    minRotation: 0
                                },
                                grid: { display: false }
                            },
                            y: {
                                id: 'y',
                                stacked: true,
                                min: minPrice,
                                max: maxPrice,
                                ticks: {
                                    color: 'white',
                                    font: { size: isMobile ? 12 : (isTablet ? 14 : 12) },
                                    stepSize: 1,
                                    callback: function (value) {
                                        return value % 5 === 0 ? value : '';
                                    }
                                },
                                grid: { display: false }
                            }
                        },
                        interaction: { mode: 'index', intersect: true },
                        onHover: function (event, elements) {
                            event.native.target.style.cursor = elements.length > 0 ? 'pointer' : 'default';
                        },
                        onClick: function (event, elements) {
                            if (elements.length === 0) return;
                            const chart = this;
                            const index = elements[0].index;

                            // Use data from global store to ensure freshness
                            let rowData = validData[index];
                            if (window.chartDataStore) {
                                const storeData = window.chartDataStore.getData(role, date);
                                if (storeData && storeData.data && storeData.data[index]) {
                                    rowData = storeData.data[index];
                                }
                            }
                            if (!rowData) return;

                            const tooltipId = 'chartjs-tooltip-click-' + role;
                            let tooltipEl = document.getElementById(tooltipId);
                            if (!tooltipEl) {
                                tooltipEl = document.createElement('div');
                                tooltipEl.id = tooltipId;
                                tooltipEl.style.cssText = 'position: absolute; pointer-events: none; opacity: 0; z-index: 1000; background: rgba(255, 255, 255, 0.95); border: 1px solid #ddd; border-radius: 4px; padding: 8px; font-family: Arial, sans-serif; font-size: 13px; box-shadow: 0 2px 8px rgba(0,0,0,0.2);';
                                document.body.appendChild(tooltipEl);
                            }

                            const [timeStr, lowPrice, mediumPrice, highPrice, marginPrice] = rowData;
                            const spotPrice = (lowPrice || 0) + (mediumPrice || 0) + (highPrice || 0);
                            const totalPrice = spotPrice + (marginPrice || 0);

                            const intervalIndex = parseInt(timeStr);
                            const hour = Math.floor(intervalIndex / 4);
                            const quarter = intervalIndex % 4;
                            const minute = quarter * 15;
                            const timeFormatted = `${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;

                            let tooltipHTML = `<div style="font-weight: bold; margin-bottom: 4px; color: #333;">${timeFormatted}</div>`;
                            if (lowPrice) tooltipHTML += `<div style="color: #666;">Price: <strong>${lowPrice.toFixed(2)} c/kWh</strong></div>`;
                            if (mediumPrice) tooltipHTML += `<div style="color: #666;">Price: <strong>${mediumPrice.toFixed(2)} c/kWh</strong></div>`;
                            if (highPrice) tooltipHTML += `<div style="color: #666;">Price: <strong>${highPrice.toFixed(2)} c/kWh</strong></div>`;
                            tooltipHTML += `<div style="color: #666;">Margin: <strong>${(marginPrice || 0).toFixed(2)} c/kWh</strong></div>`;
                            tooltipHTML += `<div style="border-top: 1px solid #ddd; margin-top: 4px; padding-top: 4px; color: #333;"><strong>Total: ${totalPrice.toFixed(2)} c/kWh</strong></div>`;

                            tooltipEl.innerHTML = tooltipHTML;
                            tooltipEl.style.opacity = '1';

                            const canvasRect = chart.canvas.getBoundingClientRect();
                            const tooltipWidth = tooltipEl.offsetWidth || 200;
                            const tooltipHeight = tooltipEl.offsetHeight || 100;
                            const x = event.native.clientX - canvasRect.left;
                            const y = event.native.clientY - canvasRect.top;

                            let leftPos = canvasRect.left + x + 10;
                            let topPos = canvasRect.top + y - tooltipHeight - 10;
                            if (leftPos + tooltipWidth > window.innerWidth) leftPos = canvasRect.left + x - tooltipWidth - 10;
                            if (topPos < 0) topPos = canvasRect.top + y + 10;

                            tooltipEl.style.left = leftPos + 'px';
                            tooltipEl.style.top = topPos + 'px';

                            const hideTooltip = function (e) {
                                if (!tooltipEl.contains(e.target) && e.target !== chart.canvas) {
                                    tooltipEl.style.opacity = '0';
                                    document.removeEventListener('click', hideTooltip);
                                }
                            };
                            setTimeout(() => document.addEventListener('click', hideTooltip), 0);
                        },
                        animation: { duration: 0 }
                    }
                };

                // Verify chart element is still in DOM
                if (!document.body.contains(chartElement)) {
                    console.error('Chart element no longer in DOM, aborting chart creation');
                    return;
                }

                // Register plugin to hide the pseudo bar at index 96
                // Bars stay in their default positions (centered on ticks), only gridlines are shifted
                if (!window._hidePseudoBarPluginRegistered) {
                    const hidePseudoBarPlugin = {
                        id: 'hidePseudoBarPlugin',
                        afterUpdate: function (chart) {
                            if (!chart.canvas || !chart.canvas._chartRole) return;

                            chart.data.datasets.forEach((dataset, datasetIndex) => {
                                const meta = chart.getDatasetMeta(datasetIndex);
                                const lastIndex = meta.data.length - 1;

                                // Hide the pseudo bar at index 96 (it has null values, won't render anyway)
                                if (lastIndex >= 0 && chart.data.labels[lastIndex] === '96') {
                                    if (meta.data[lastIndex]) {
                                        meta.data[lastIndex].hidden = true;
                                    }
                                }
                            });
                        }
                    };

                    Chart.register(hidePseudoBarPlugin);
                    window._hidePseudoBarPluginRegistered = true;
                    console.log('Hide pseudo bar plugin registered');
                }

                // Create chart
                let chart;
                try {
                    chart = new Chart(chartElement, chartConfig);
                } catch (e) {
                    console.error('Error creating chart:', e);
                    chartElement.parentElement.innerHTML = '<div style="color: white; padding: 20px; text-align: center;">Error creating chart</div>';
                    return;
                }

                // Register chart instance with global registry INCLUDING date
                if (window.chartRegistry) {
                    window.chartRegistry.registerChart(chartElement, chart, role, date);
                }

                // Add hour labels
                chart.canvas.parentElement.style.position = 'relative';
                const labelContainer = document.createElement('div');
                labelContainer.style.cssText = 'position: absolute; bottom: 0; left: 0; right: 0; height: 50px; pointer-events: none;';
                labelContainer.className = 'chart-hour-labels';
                chart.canvas.parentElement.appendChild(labelContainer);

                function updateHourLabels() {
                    if (!document.body.contains(labelContainer)) return;
                    labelContainer.innerHTML = '';

                    const chartArea = chart.chartArea;
                    const scale = chart.scales.x;
                    if (!chartArea || !scale) {
                        setTimeout(updateHourLabels, 100);
                        return;
                    }

                    // Check if mobile vertical mode (mobile width AND portrait orientation)
                    const isMobileVertical = isMobile && window.innerHeight > window.innerWidth;

                    // Calculate current time for relative labels (works for both today and tomorrow)
                    const now = new Date();
                    const currentHour = now.getHours();
                    const currentMinutes = now.getMinutes();
                    const currentQuarter = Math.floor(currentMinutes / 15);
                    const currentIntervalIndex = currentHour * 4 + currentQuarter;

                    // For today's chart: find current position in data
                    // For tomorrow's chart: calculate offset from midnight
                    let currentDataPointIndex = null;
                    let chartStartHour = 0;
                    let chartStartMinutes = 0;

                    if (role === 'today') {
                        // Find current time position in today's data
                        currentDataPointIndex = validData.findIndex(row => {
                            const intervalIndex = parseInt(row[0]);
                            return intervalIndex === currentIntervalIndex;
                        });
                    } else if (role === 'tomorrow') {
                        // For tomorrow, calculate how many hours from now until tomorrow at the same minute
                        // If current time is 15:30, tomorrow at 0:30 is 9 hours away
                        const hoursUntilTomorrow = 24 - currentHour;
                        const minutesUntilTomorrow = hoursUntilTomorrow * 60 - currentMinutes;
                        // The first relative label in tomorrow's chart should be at 0:currentMinutes
                        chartStartHour = 0;
                        chartStartMinutes = currentMinutes;
                    }

                    // Draw absolute hour labels (restore original position)
                    for (let hour = 0; hour < 24; hour++) {
                        // On mobile vertical mode, only show every 2nd hour (0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22)
                        if (isMobileVertical && hour % 2 !== 0) {
                            continue;
                        }

                        const dataPointIndex = hour * 4;
                        if (dataPointIndex < labels.length) {
                            try {
                                const xPos = scale.getPixelForValue(dataPointIndex);
                                const barPercentage = (isMobile || isTablet) ? 0.95 : 0.90;
                                const categoryWidth = scale.width / labels.length;
                                const barWidth = categoryWidth * barPercentage;
                                const leftEdge = xPos - (barWidth / 2);

                                // Hour label (absolute hour) - restore original position at bottom: 5px
                                const label = document.createElement('div');
                                label.textContent = hour.toString();
                                label.style.cssText = `position: absolute; left: ${leftEdge}px; bottom: 5px; color: white; font-size: 12px; font-family: Arial, sans-serif; pointer-events: none; white-space: nowrap;`;
                                labelContainer.appendChild(label);
                            } catch (e) {
                                console.warn('Error positioning hour label:', e);
                            }
                        }
                    }

                    // Draw relative hour labels (+1, +2, +3, etc.) positioned relative to now line
                    if (role === 'today' && currentDataPointIndex !== null && currentDataPointIndex >= 0) {
                        // Calculate current time position in pixels
                        const nowXPos = scale.getPixelForValue(currentDataPointIndex);

                        // Draw labels for each hour after current time
                        // Start from +1 (1 hour after current time)
                        for (let relativeHour = 1; relativeHour <= 48; relativeHour++) { // Up to 48 hours ahead
                            // Calculate target time: current time + relativeHour hours
                            const targetTotalMinutes = currentMinutes + (relativeHour * 60);
                            const targetHours = currentHour + Math.floor(targetTotalMinutes / 60);
                            const targetMinutes = targetTotalMinutes % 60;
                            const targetHour = targetHours % 24;

                            // Check if this is still within today (before midnight)
                            if (targetHours >= 24) {
                                break; // Beyond today, stop here
                            }

                            // Calculate interval index for target time
                            const targetQuarter = Math.floor(targetMinutes / 15);
                            const targetIntervalIndex = targetHour * 4 + targetQuarter;

                            // Find data point index
                            const targetDataPointIndex = validData.findIndex(row => {
                                const intervalIndex = parseInt(row[0]);
                                return intervalIndex === targetIntervalIndex;
                            });

                            if (targetDataPointIndex >= 0 && targetDataPointIndex < validData.length) {
                                try {
                                    const xPos = scale.getPixelForValue(targetDataPointIndex);
                                    const barPercentage = (isMobile || isTablet) ? 0.95 : 0.90;
                                    const categoryWidth = scale.width / labels.length;
                                    const barWidth = categoryWidth * barPercentage;
                                    const leftEdge = xPos - (barWidth / 2);

                                    const relativeLabel = document.createElement('div');
                                    relativeLabel.textContent = `+${relativeHour}`;
                                    relativeLabel.style.cssText = `position: absolute; left: ${leftEdge}px; bottom: -15px; color: rgba(255, 255, 255, 0.7); font-size: 11px; font-family: Arial, sans-serif; pointer-events: none; white-space: nowrap;`;
                                    labelContainer.appendChild(relativeLabel);
                                } catch (e) {
                                    console.warn('Error positioning relative hour label:', e);
                                }
                            } else {
                                // No more data available
                                break;
                            }
                        }
                    } else if (role === 'tomorrow') {
                        // For tomorrow's chart, continue from where today left off
                        // Calculate how many hours from now until tomorrow at the same minute
                        // If current time is 15:30, tomorrow at 0:30 is 9 hours away, so label it +9
                        // Time until midnight: (24 - currentHour) hours
                        // Time from midnight to 0:currentMinutes: currentMinutes (already included in the hour calculation)
                        // So total hours = 24 - currentHour
                        // But we need to account for the minutes: if it's 15:30, time to 0:30 is exactly 9 hours
                        // If it's 15:00, time to 0:00 is 9 hours, but we want 0:currentMinutes which would be 0:00 = 9 hours
                        // Actually, if current is 15:00 and we want 0:00, that's 9 hours. If current is 15:30 and we want 0:30, that's also 9 hours.
                        // So firstRelativeHour = 24 - currentHour (always, since we're going to the same minute)
                        const firstRelativeHour = 24 - currentHour;

                        // Start labeling from tomorrow at the same minute as current time
                        const startHour = 0;
                        const startMinutes = currentMinutes;
                        const startQuarter = Math.floor(startMinutes / 15);
                        const startIntervalIndex = startHour * 4 + startQuarter;

                        // Find starting position in tomorrow's data
                        const startDataPointIndex = validData.findIndex(row => {
                            const intervalIndex = parseInt(row[0]);
                            return intervalIndex === startIntervalIndex;
                        });

                        if (startDataPointIndex >= 0) {
                            // Draw labels starting from firstRelativeHour
                            // Continue for up to 24 more hours (full day)
                            for (let offset = 0; offset < 24; offset++) {
                                const relativeHour = firstRelativeHour + offset;

                                // Calculate target time in tomorrow: start time + offset hours
                                const targetTotalMinutes = startMinutes + (offset * 60);
                                const targetHours = startHour + Math.floor(targetTotalMinutes / 60);
                                const targetMinutes = targetTotalMinutes % 60;
                                const targetHour = targetHours % 24;

                                // Check if still within tomorrow (before next day)
                                if (targetHours >= 24) {
                                    break;
                                }

                                // Calculate interval index for target time
                                const targetQuarter = Math.floor(targetMinutes / 15);
                                const targetIntervalIndex = targetHour * 4 + targetQuarter;

                                // Find data point index
                                const targetDataPointIndex = validData.findIndex(row => {
                                    const intervalIndex = parseInt(row[0]);
                                    return intervalIndex === targetIntervalIndex;
                                });

                                if (targetDataPointIndex >= 0 && targetDataPointIndex < validData.length) {
                                    try {
                                        const xPos = scale.getPixelForValue(targetDataPointIndex);
                                        const barPercentage = (isMobile || isTablet) ? 0.95 : 0.90;
                                        const categoryWidth = scale.width / labels.length;
                                        const barWidth = categoryWidth * barPercentage;
                                        const leftEdge = xPos - (barWidth / 2);

                                        const relativeLabel = document.createElement('div');
                                        relativeLabel.textContent = `+${relativeHour}`;
                                        relativeLabel.style.cssText = `position: absolute; left: ${leftEdge}px; bottom: -15px; color: rgba(255, 255, 255, 0.7); font-size: 11px; font-family: Arial, sans-serif; pointer-events: none; white-space: nowrap;`;
                                        labelContainer.appendChild(relativeLabel);
                                    } catch (e) {
                                        console.warn('Error positioning relative hour label:', e);
                                    }
                                } else {
                                    // No more data available
                                    break;
                                }
                            }
                        }
                    }
                }

                chart.update();
                setTimeout(updateHourLabels, 100);

                const originalResize = chart.resize;
                chart.resize = function () {
                    originalResize.call(this);
                    setTimeout(updateHourLabels, 100);
                };

                // Final generation check before storing
                if (window._chartGeneration[role] !== thisGeneration) {
                    console.warn(`Chart ${role}: generation ${thisGeneration} became stale during creation, destroying`);
                    chart.destroy();
                    return;
                }

                // Store chart instance and metadata on canvas (for compatibility)
                chartElement._chartInstance = chart;
                chartElement._chartDate = date;  // Store the date this chart was created for
                chartElement._chartRole = role;
                chartElement._chartGeneration = thisGeneration;  // Store generation for timer validation
                chartElement._updateHourLabels = updateHourLabels;  // Store function reference for updating labels

                // Set up now line timer for today's chart
                if (role === 'today') {
                    setupNowLineTimer(role, date, thisGeneration);
                    if (window.updateCurrentPrice) {
                        window.updateCurrentPrice();
                    }
                }

                console.log(`Chart created successfully for ${role} (gen ${thisGeneration}), date: ${date}, dataPoints: ${validData.length}`);
            })
            .catch(error => {
                console.error('Error fetching chart data:', error);
                if (document.body.contains(chartElement)) {
                    chartElement.parentElement.innerHTML = '<div style="color: white; padding: 20px;">Error loading chart data</div>';
                }
            });

        // Now line timer that uses global data store and validates generation
        function setupNowLineTimer(role, chartDate, generation) {
            function updateNowLineFromStore() {
                // Check if this timer's generation is still current
                if (window._chartGeneration[role] !== generation) {
                    console.log(`Now line timer (gen ${generation}): stale, current is ${window._chartGeneration[role]}`);
                    return;
                }

                if (document.hidden) return;

                // Get current expected date
                const expectedDate = window.getHelsinkiDate ? window.getHelsinkiDate(0) : null;

                // If date has changed, don't update - let the refresh handle it
                if (expectedDate && chartDate !== expectedDate) {
                    console.log('Now line timer: date changed, skipping update');
                    return;
                }

                // Verify the chart canvas still matches our generation
                const canvas = document.querySelector('#todayChart canvas');
                if (!canvas || canvas._chartGeneration !== generation) {
                    console.log(`Now line timer (gen ${generation}): canvas generation mismatch`);
                    return;
                }

                // Use global updateNowLine which reads from data store
                if (window.updateNowLine) {
                    window.updateNowLine();
                }

                // Update hour labels for both today and tomorrow charts
                // This ensures relative labels (+1, +2, etc.) are repositioned when now line moves
                const todayCanvas = document.querySelector('#todayChart canvas');
                if (todayCanvas && todayCanvas._updateHourLabels) {
                    try {
                        todayCanvas._updateHourLabels();
                    } catch (e) {
                        console.warn('Error updating today chart hour labels:', e);
                    }
                }

                const tomorrowCanvas = document.querySelector('#tomorrowChart canvas');
                if (tomorrowCanvas && tomorrowCanvas._updateHourLabels) {
                    try {
                        tomorrowCanvas._updateHourLabels();
                    } catch (e) {
                        console.warn('Error updating tomorrow chart hour labels:', e);
                    }
                }
            }

            function msUntilNext15Min() {
                const now = new Date();
                const minutes = now.getMinutes();
                const seconds = now.getSeconds();
                const ms = now.getMilliseconds();
                const nextBoundary = Math.ceil(minutes / 15) * 15;
                const minutesUntil = nextBoundary === 60 ? (60 - minutes) : (nextBoundary - minutes);
                return (minutesUntil * 60 * 1000) - (seconds * 1000) - ms;
            }

            function scheduleNext() {
                // Don't schedule if already stale
                if (window._chartGeneration[role] !== generation) {
                    console.log(`Now line timer (gen ${generation}): not scheduling, already stale`);
                    return;
                }

                const ms = msUntilNext15Min();
                console.log(`Now line timer (gen ${generation}): scheduling for ${ms}ms`);

                const timeoutId = setTimeout(() => {
                    // Check generation before doing anything
                    if (window._chartGeneration[role] !== generation) {
                        console.log(`Now line timer (gen ${generation}): timeout fired but stale`);
                        return;
                    }

                    updateNowLineFromStore();

                    // Only set up interval if still current generation
                    if (window._chartGeneration[role] === generation) {
                        const intervalId = setInterval(() => {
                            if (window._chartGeneration[role] !== generation) {
                                // Clear this interval since we're stale
                                clearInterval(intervalId);
                                return;
                            }
                            updateNowLineFromStore();
                        }, 15 * 60 * 1000);

                        if (window.chartRegistry) {
                            window.chartRegistry.trackTimer(intervalId, role, 'now-line-interval');
                        }
                    }
                }, ms);

                if (window.chartRegistry) {
                    window.chartRegistry.trackTimer(timeoutId, role, 'now-line-timeout');
                }
            }

            scheduleNext();
        }
    };

    // Execute chart creation
    if (typeof Chart !== 'undefined') {
        window.createChart('{{ chart_date }}', '{{ chart_role }}');
    } else {
        const checkChart = setInterval(() => {
            if (typeof Chart !== 'undefined') {
                clearInterval(checkChart);
                window.createChart('{{ chart_date }}', '{{ chart_role }}');
            }
        }, 100);
    }
</script>
