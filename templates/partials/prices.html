{% set entries = vm.entries %}
{% set max_total = vm.maxTotal %}
{% set chart_date = request.query_params.get('date', 'today') %}
{% set chart_id = 'chart_' ~ chart_date %}
{% set date_string_id = 'dateString_' ~ chart_date %}
<section id="{{ chart_date }}Chart" class="chart" aria-label="Prices chart" data-date="{{ chart_date }}"
    data-margin="{{ request.query_params.get('margin', '0') }}">
    <div class="chart-head">
        {{ chart_date|title }}
        <span class="date-string" id="{{ date_string_id }}"></span>
    </div>
    <div class="chart-body">
        <canvas id="{{ chart_id }}"></canvas>
    </div>
</section>

<script>
    // Create chart for {{ chart_date }}
    window.createChart = function (chartDate) {
        const date = chartDate || '{{ chart_date }}';
        const margin = '{{ request.query_params.get("margin", "0") }}';
        const chartId = 'chart_' + date;
        const dateStringId = 'dateString_' + date;
        const chartElement = document.getElementById(chartId);
        const dateStringEl = document.getElementById(dateStringId);

        // Get chart section to update the header text
        const chartSection = document.getElementById(date + 'Chart');
        const chartHeadEl = chartSection ? chartSection.querySelector('.chart-head') : null;

        if (!chartElement) {
            console.error('Chart element not found:', chartId);
            return;
        }

        // Localize the "Today" or "Tomorrow" label
        if (chartHeadEl) {
            let localizedLabel;
            if (date === 'today') {
                const translations = {
                    'en': 'Today',
                    'fi': 'Tänään',
                    'sv': 'Idag',
                    'de': 'Heute',
                    'fr': "Aujourd'hui",
                    'es': 'Hoy',
                    'it': 'Oggi',
                    'nl': 'Vandaag',
                    'pt': 'Hoje',
                    'ru': 'Сегодня',
                    'pl': 'Dzisiaj',
                };
                const lang = navigator.language.split('-')[0];
                localizedLabel = translations[lang] || translations['en'];
            } else if (date === 'tomorrow') {
                const translations = {
                    'en': 'Tomorrow',
                    'fi': 'Huomenna',
                    'sv': 'Imorgon',
                    'de': 'Morgen',
                    'fr': 'Demain',
                    'es': 'Mañana',
                    'it': 'Domani',
                    'nl': 'Morgen',
                    'pt': 'Amanhã',
                    'ru': 'Завтра',
                    'pl': 'Jutro',
                };
                const lang = navigator.language.split('-')[0];
                localizedLabel = translations[lang] || translations['en'];
            } else {
                localizedLabel = chartHeadEl.textContent.split(' - ')[0] || date;
            }
            chartHeadEl.innerHTML = localizedLabel +
                `<span class="date-string" id="${dateStringId}"></span>`;
        }

        // Check if chart already exists and destroy it
        if (chartElement._chartInstance) {
            chartElement._chartInstance.destroy();
            chartElement._chartInstance = null;
        }

        // Clean up timers
        if (chartElement._nowLineTimer) {
            clearInterval(chartElement._nowLineTimer);
            clearTimeout(chartElement._nowLineTimer);
        }
        if (chartElement._visibilityHandler) {
            document.removeEventListener('visibilitychange', chartElement._visibilityHandler);
        }
        if (chartElement._focusHandler) {
            window.removeEventListener('focus', chartElement._focusHandler);
        }
        if (chartElement._pageShowHandler) {
            window.removeEventListener('pageshow', chartElement._pageShowHandler);
        }
        if (chartElement._pageHideHandler) {
            window.removeEventListener('pagehide', chartElement._pageHideHandler);
        }

        console.log('Creating chart for:', date, 'margin:', margin);

        // Fetch chart data
        let dateStr;
        if (date === 'today') {
            dateStr = 'today';
        } else if (date === 'tomorrow') {
            dateStr = 'tomorrow';
        } else {
            dateStr = date;
        }

        fetch(`/api/chart-data?date_str=${dateStr}&margin=${margin}`)
            .then(response => response.json())
            .then(data => {
                console.log('Chart data received for', date, ':', data);

                // Track metadata
                const fetchTime = Date.now();
                const fetchDate = new Date(fetchTime);
                if (window.chartDataTimestamps) {
                    window.chartDataTimestamps[date] = fetchTime;
                }
                if (window.chartDataMetadata) {
                    window.chartDataMetadata[date] = {
                        fetchedDate: fetchDate.toDateString(),
                        fetchedHour: fetchDate.getHours()
                    };
                }

                // Update date string with localized format
                const currentDateStringEl = document.getElementById(dateStringId);
                if (currentDateStringEl) {
                    let formattedDate;
                    if (data.dateIso) {
                        const dateObj = new Date(data.dateIso);
                        if (!isNaN(dateObj.getTime())) {
                            const dateFormatter = new Intl.DateTimeFormat(undefined, {
                                weekday: 'long',
                                year: 'numeric',
                                month: 'numeric',
                                day: 'numeric'
                            });
                            let dateStr = dateFormatter.format(dateObj);
                            const lang = navigator.language.split('-')[0];
                            if (lang === 'fi') {
                                const weekdays = {
                                    'maanantaina': 'maanantai',
                                    'tiistaina': 'tiistai',
                                    'keskiviikkona': 'keskiviikko',
                                    'torstaina': 'torstai',
                                    'perjantaina': 'perjantai',
                                    'lauantaina': 'lauantai',
                                    'sunnuntaina': 'sunnuntai'
                                };
                                for (const [inessive, nominative] of Object.entries(weekdays)) {
                                    if (dateStr.toLowerCase().includes(inessive)) {
                                        dateStr = dateStr.replace(new RegExp(inessive, 'gi'), nominative);
                                        break;
                                    }
                                }
                            }
                            formattedDate = dateStr;
                        } else {
                            formattedDate = data.dateString;
                        }
                    } else {
                        formattedDate = data.dateString || '';
                    }
                    currentDateStringEl.textContent = ` - ${formattedDate}`;
                }

                // Validate data
                const validData = data.data.filter(row => Array.isArray(row) && row.length === 5);
                if (validData.length === 0) {
                    chartElement.parentElement.innerHTML = '<div style="color: white; padding: 20px; text-align: center;">No data available</div>';
                    return;
                }

                // Process data for Chart.js
                const labels = [];
                const lowData = [];
                const medData = [];
                const highData = [];
                const marginData = [];
                const tooltips = [];

                validData.forEach(row => {
                    const [timeStr, lowPrice, mediumPrice, highPrice, marginPrice] = row;
                    labels.push(timeStr);

                    // Format time for tooltip
                    let timeFormatted;
                    if (data.granularity === 'quarter_hour') {
                        const intervalIndex = parseInt(timeStr);
                        const hour = Math.floor(intervalIndex / 4);
                        const quarter = intervalIndex % 4;
                        const minute = quarter * 15;
                        timeFormatted = `${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;
                    } else {
                        const hour = parseInt(timeStr);
                        timeFormatted = `${hour.toString().padStart(2, '0')}:00`;
                    }

                    const spotPrice = (lowPrice || 0) + (mediumPrice || 0) + (highPrice || 0);
                    const totalPrice = spotPrice + (marginPrice || 0);

                    // Create tooltip HTML
                    let tooltipContent = `
                        <div style="padding: 8px; font-family: Arial, sans-serif; font-size: 13px; line-height: 1.4;">
                            <div style="font-weight: bold; margin-bottom: 4px; color: #333;">${timeFormatted}</div>
                    `;
                    if (lowPrice !== 0 && lowPrice !== null && lowPrice !== undefined) {
                        tooltipContent += `<div style="color: #666;">Price: <strong>${lowPrice.toFixed(2)} c/kWh</strong></div>`;
                    }
                    if (mediumPrice !== 0 && mediumPrice !== null && mediumPrice !== undefined) {
                        tooltipContent += `<div style="color: #666;">Price: <strong>${mediumPrice.toFixed(2)} c/kWh</strong></div>`;
                    }
                    if (highPrice !== 0 && highPrice !== null && highPrice !== undefined) {
                        tooltipContent += `<div style="color: #666;">Price: <strong>${highPrice.toFixed(2)} c/kWh</strong></div>`;
                    }
                    tooltipContent += `<div style="color: #666;">Margin: <strong>${(marginPrice || 0).toFixed(2)} c/kWh</strong></div>`;
                    tooltipContent += `
                            <div style="border-top: 1px solid #ddd; margin-top: 4px; padding-top: 4px; color: #333;">
                                <strong>Total: ${totalPrice.toFixed(2)} c/kWh</strong>
                            </div>
                        </div>
                    `;
                    tooltips.push(tooltipContent.trim());

                    // Use null for zero values to skip rendering
                    lowData.push(lowPrice !== 0 ? lowPrice : null);
                    medData.push(mediumPrice !== 0 ? mediumPrice : null);
                    highData.push(highPrice !== 0 ? highPrice : null);
                    marginData.push(marginPrice !== 0 ? marginPrice : null);
                });

                // Responsive settings
                const isMobile = window.innerWidth <= 900;
                const isTablet = window.innerWidth > 900 && window.innerWidth <= 1200;
                const maxPrice = Math.max(15, data.maxPrice);
                const minPrice = data.minPrice;

                // Prepare annotations for gridlines, vertical lines, and now line
                const annotations = {
                    x: [],
                    y: []
                };

                // Add hourly vertical lines
                const hourStep = data.granularity === 'quarter_hour' ? 4 : 1;
                for (let hour = 0; hour < 24; hour++) {
                    const dataPointIndex = hour * hourStep;
                    if (dataPointIndex < validData.length) {
                        annotations.x.push({
                            type: 'line',
                            xMin: dataPointIndex,
                            xMax: dataPointIndex,
                            borderColor: '#555555',
                            borderWidth: 1,
                            opacity: 0.5
                        });
                    }
                }

                // Add horizontal gridlines (every 1 cent, major every 5)
                for (let price = minPrice; price <= maxPrice; price += 1) {
                    const isMajor = price % 5 === 0;
                    annotations.y.push({
                        type: 'line',
                        yMin: price,
                        yMax: price,
                        borderColor: isMajor ? '#aaaaaa' : '#666666',
                        borderWidth: isMajor ? 2 : 1.5,
                        opacity: isMajor ? 1.0 : 0.7
                    });
                }

                // Add now line for today's chart
                if (date === 'today') {
                    const now = new Date();
                    const currentHour = now.getHours();
                    const currentMinutes = now.getMinutes();
                    let dataPointIndex = -1;

                    if (data.granularity === 'quarter_hour') {
                        const quarter = Math.floor(currentMinutes / 15);
                        const intervalIndex = currentHour * 4 + quarter;
                        dataPointIndex = validData.findIndex(row => row[0] === intervalIndex.toString());
                    } else {
                        dataPointIndex = validData.findIndex(row => row[0] === currentHour.toString());
                    }

                    if (dataPointIndex >= 0) {
                        annotations.x.push({
                            type: 'line',
                            xMin: dataPointIndex,
                            xMax: dataPointIndex,
                            borderColor: '#ff9900',
                            borderWidth: 3,
                            borderDash: [4, 3],
                            opacity: 0.9,
                            label: {
                                display: false
                            }
                        });
                    }
                }

                // Chart.js configuration
                const chartConfig = {
                    type: 'bar',
                    data: {
                        labels: labels,
                        datasets: [
                            {
                                label: 'Low Price',
                                data: lowData,
                                backgroundColor: '#2ecc71',
                                stack: 'price'
                            },
                            {
                                label: 'Medium Price',
                                data: medData,
                                backgroundColor: '#f1c40f',
                                stack: 'price'
                            },
                            {
                                label: 'High Price',
                                data: highData,
                                backgroundColor: '#e74c3c',
                                stack: 'price'
                            },
                            {
                                label: 'Margin',
                                data: marginData,
                                backgroundColor: '#666666',
                                stack: 'price'
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                display: false
                            },
                            tooltip: {
                                enabled: true,
                                mode: 'index',
                                intersect: false,
                                backgroundColor: 'rgba(255, 255, 255, 0.95)',
                                titleColor: '#333',
                                bodyColor: '#666',
                                borderColor: '#ddd',
                                borderWidth: 1,
                                padding: 8,
                                callbacks: {
                                    title: function (context) {
                                        const index = context[0].dataIndex;
                                        const timeStr = labels[index];
                                        if (data.granularity === 'quarter_hour') {
                                            const intervalIndex = parseInt(timeStr);
                                            const hour = Math.floor(intervalIndex / 4);
                                            const quarter = intervalIndex % 4;
                                            const minute = quarter * 15;
                                            return `${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;
                                        } else {
                                            const hour = parseInt(timeStr);
                                            return `${hour.toString().padStart(2, '0')}:00`;
                                        }
                                    },
                                    label: function (context) {
                                        const datasetLabel = context.dataset.label || '';
                                        const value = context.parsed.y;
                                        if (value === null || value === undefined) return '';
                                        return datasetLabel + ': ' + value.toFixed(2) + ' c/kWh';
                                    },
                                    footer: function (context) {
                                        const index = context[0].dataIndex;
                                        const row = validData[index];
                                        if (!row) return '';
                                        const [, lowPrice, mediumPrice, highPrice, marginPrice] = row;
                                        const spotPrice = (lowPrice || 0) + (mediumPrice || 0) + (highPrice || 0);
                                        const totalPrice = spotPrice + (marginPrice || 0);
                                        return 'Total: ' + totalPrice.toFixed(2) + ' c/kWh';
                                    }
                                }
                            },
                            annotation: {
                                annotations: annotations
                            }
                        },
                        scales: {
                            x: {
                                stacked: true,
                                display: true,
                                barPercentage: (isMobile || isTablet) ? 0.95 : 0.90,
                                categoryPercentage: 1.0,
                                ticks: {
                                    color: data.granularity === 'quarter_hour' ? 'transparent' : 'white',
                                    font: {
                                        size: isMobile ? 10 : (isTablet ? 14 : 12)
                                    },
                                    callback: function (value, index) {
                                        // For quarter-hour, show only hours (0-23) at every 4th position
                                        if (data.granularity === 'quarter_hour') {
                                            if (index % 4 === 0) {
                                                return Math.floor(index / 4).toString();
                                            }
                                            return '';
                                        }
                                        return value.toString();
                                    },
                                    maxRotation: 0,
                                    minRotation: 0
                                },
                                grid: {
                                    display: false
                                }
                            },
                            y: {
                                stacked: true,
                                min: minPrice,
                                max: maxPrice,
                                ticks: {
                                    color: 'white',
                                    font: {
                                        size: isMobile ? 12 : (isTablet ? 14 : 12)
                                    },
                                    stepSize: 1,
                                    callback: function (value) {
                                        return value % 5 === 0 ? value : '';
                                    }
                                },
                                grid: {
                                    display: false
                                }
                            }
                        },
                        interaction: {
                            mode: 'index',
                            intersect: false
                        },
                        animation: {
                            duration: 0
                        }
                    }
                };

                // Create chart
                const chart = new Chart(chartElement, chartConfig);

                // Store chart instance and metadata
                chartElement._chartInstance = chart;
                chartElement._validData = validData;
                chartElement._granularity = data.granularity;
                chartElement._originalPriceRange = {
                    minPrice: minPrice,
                    maxPrice: maxPrice
                };
                chartElement._tooltips = tooltips;

                // Set up now line timer for today's chart
                if (date === 'today') {
                    startNowLineTimer(chart, chartElement, validData, data.granularity);
                    if (window.updateCurrentPrice) {
                        window.updateCurrentPrice();
                    }
                }

                // Handle window resize
                let resizeTimer;
                window.addEventListener('resize', () => {
                    clearTimeout(resizeTimer);
                    resizeTimer = setTimeout(() => {
                        if (chartElement._chartInstance) {
                            chartElement._chartInstance.resize();
                        }
                    }, 250);
                });

                console.log('Chart created successfully');
            })
            .catch(error => {
                console.error('Error fetching chart data:', error);
                chartElement.parentElement.innerHTML = '<div style="color: white; padding: 20px;">Error loading chart data</div>';
            });

        function startNowLineTimer(chart, chartElement, validData, granularity) {
            // Clear existing timer
            if (chartElement._nowLineTimer) {
                clearInterval(chartElement._nowLineTimer);
                clearTimeout(chartElement._nowLineTimer);
            }

            function updateNowLine() {
                if (document.hidden) return;

                const now = new Date();
                const currentHour = now.getHours();
                const currentMinutes = now.getMinutes();
                let dataPointIndex = -1;

                if (granularity === 'quarter_hour') {
                    const quarter = Math.floor(currentMinutes / 15);
                    const intervalIndex = currentHour * 4 + quarter;
                    dataPointIndex = validData.findIndex(row => row[0] === intervalIndex.toString());
                } else {
                    dataPointIndex = validData.findIndex(row => row[0] === currentHour.toString());
                }

                if (dataPointIndex >= 0 && chartElement._chartInstance) {
                    const annotations = chartElement._chartInstance.options.plugins.annotation.annotations;
                    // Remove existing now line
                    const nowLineIndex = annotations.x.findIndex(a => a.borderColor === '#ff9900');
                    if (nowLineIndex >= 0) {
                        annotations.x.splice(nowLineIndex, 1);
                    }
                    // Add new now line
                    annotations.x.push({
                        type: 'line',
                        xMin: dataPointIndex,
                        xMax: dataPointIndex,
                        borderColor: '#ff9900',
                        borderWidth: 3,
                        borderDash: [4, 3],
                        opacity: 0.9
                    });
                    chartElement._chartInstance.update('none');
                }
            }

            // Calculate ms until next 15-minute boundary
            function msUntilNext15Min() {
                const now = new Date();
                const minutes = now.getMinutes();
                const seconds = now.getSeconds();
                const ms = now.getMilliseconds();
                const nextBoundary = Math.ceil(minutes / 15) * 15;
                const minutesUntil = nextBoundary === 60 ? (60 - minutes) : (nextBoundary - minutes);
                return (minutesUntil * 60 * 1000) - (seconds * 1000) - ms;
            }

            function scheduleNext() {
                const ms = msUntilNext15Min();
                chartElement._nowLineTimer = setTimeout(() => {
                    updateNowLine();
                    chartElement._nowLineTimer = setInterval(updateNowLine, 15 * 60 * 1000);
                }, ms);
            }

            scheduleNext();

            const visibilityHandler = () => {
                if (!document.hidden) {
                    updateNowLine();
                    if (chartElement._nowLineTimer) {
                        clearInterval(chartElement._nowLineTimer);
                        clearTimeout(chartElement._nowLineTimer);
                    }
                    scheduleNext();
                }
            };

            chartElement._visibilityHandler = visibilityHandler;
            document.addEventListener('visibilitychange', visibilityHandler);

            const focusHandler = () => {
                updateNowLine();
                if (chartElement._nowLineTimer) {
                    clearInterval(chartElement._nowLineTimer);
                    clearTimeout(chartElement._nowLineTimer);
                }
                scheduleNext();
            };

            chartElement._focusHandler = focusHandler;
            window.addEventListener('focus', focusHandler);
        }
    };

    // Execute chart creation
    if (typeof Chart !== 'undefined') {
        window.createChart('{{ chart_date }}');
    } else {
        const checkChart = setInterval(() => {
            if (typeof Chart !== 'undefined') {
                clearInterval(checkChart);
                window.createChart('{{ chart_date }}');
            }
        }, 100);
    }
</script>
